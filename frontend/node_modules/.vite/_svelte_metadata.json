{"compilerOptions":{"css":"external","dev":true,"hydratable":true},"configFile":false,"extensions":[".svelte"],"preprocess":[{"script":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+page.') || basename.startsWith('+layout.')) {\n\t\t\tconst match = content.match(options_regex);\n\t\t\tif (match) {\n\t\t\t\tconst fixed = basename.replace('.svelte', '(.server).js/ts');\n\n\t\t\t\tconst message =\n\t\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t\t`\\`${match[1]}\\` will be ignored — move it to ${fixed} instead. See https://kit.svelte.dev/docs/page-options for more information.`;\n\n\t\t\t\tif (!warned.has(message)) {\n\t\t\t\t\tconsole.log(message);\n\t\t\t\t\twarned.add(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","markup":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tconst has_children =\n\t\t\tcontent.includes('<slot') || (isSvelte5Plus() && content.includes('{@render'));\n\n\t\tif (basename.startsWith('+layout.') && !has_children) {\n\t\t\tconst message =\n\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t`\\`<slot />\\`${isSvelte5Plus() ? ' or `{@render ...}` tag' : ''}` +\n\t\t\t\t' missing — inner content will not be rendered';\n\n\t\t\tif (!warned.has(message)) {\n\t\t\t\tconsole.log(message);\n\t\t\t\twarned.add(message);\n\t\t\t}\n\t\t}\n\t}"},{"markup":"async markup({ content, filename }) {\n\t\t\tif (!content.includes('<enhanced:img')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst s = new MagicString(content);\n\t\t\tconst ast = parse(content, { filename });\n\n\t\t\t// Import path to import name\n\t\t\t// e.g. ./foo.png => ___ASSET___0\n\t\t\t/** @type {Map<string, string>} */\n\t\t\tconst imports = new Map();\n\n\t\t\t/**\n\t\t\t * @param {import('svelte/types/compiler/interfaces').TemplateNode} node\n\t\t\t * @param {{ type: string, start: number, end: number, raw: string }} src_attribute\n\t\t\t * @returns {Promise<void>}\n\t\t\t */\n\t\t\tasync function update_element(node, src_attribute) {\n\t\t\t\t// TODO: this will become ExpressionTag in Svelte 5\n\t\t\t\tif (src_attribute.type === 'MustacheTag') {\n\t\t\t\t\tconst src_var_name = content\n\t\t\t\t\t\t.substring(src_attribute.start + 1, src_attribute.end - 1)\n\t\t\t\t\t\t.trim();\n\t\t\t\t\ts.update(node.start, node.end, dynamic_img_to_picture(content, node, src_var_name));\n\t\t\t\t\treturn;\n\t\t\t\t} else if (src_attribute.type === 'AttributeShorthand') {\n\t\t\t\t\tconst src_var_name = content.substring(src_attribute.start, src_attribute.end).trim();\n\t\t\t\t\ts.update(node.start, node.end, dynamic_img_to_picture(content, node, src_var_name));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst original_url = src_attribute.raw.trim();\n\t\t\t\tlet url = original_url;\n\n\t\t\t\tconst sizes = get_attr_value(node, 'sizes');\n\t\t\t\tconst width = get_attr_value(node, 'width');\n\t\t\t\turl += url.includes('?') ? '&' : '?';\n\t\t\t\tif (sizes) {\n\t\t\t\t\turl += 'imgSizes=' + encodeURIComponent(sizes.raw) + '&';\n\t\t\t\t}\n\t\t\t\tif (width) {\n\t\t\t\t\turl += 'imgWidth=' + encodeURIComponent(width.raw) + '&';\n\t\t\t\t}\n\t\t\t\turl += 'enhanced';\n\n\t\t\t\tif (OPTIMIZABLE.test(url)) {\n\t\t\t\t\t// resolves the import so that we can build the entire picture template string and don't\n\t\t\t\t\t// need any logic blocks\n\t\t\t\t\tconst resolved_id = (await opts.plugin_context.resolve(url, filename))?.id;\n\t\t\t\t\tif (!resolved_id) {\n\t\t\t\t\t\tconst file_path = url.substring(0, url.indexOf('?'));\n\t\t\t\t\t\tif (existsSync(path.resolve(opts.vite_config.publicDir, file_path))) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Could not locate ${file_path}. Please move it to be located relative to the page in the routes directory or reference it beginning with /static/. See https://vitejs.dev/guide/assets for more details on referencing assets.`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Could not locate ${file_path}. See https://vitejs.dev/guide/assets for more details on referencing assets.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet image = images.get(resolved_id);\n\t\t\t\t\tif (!image) {\n\t\t\t\t\t\timage = await process(resolved_id, opts);\n\t\t\t\t\t\timages.set(resolved_id, image);\n\t\t\t\t\t}\n\t\t\t\t\ts.update(node.start, node.end, img_to_picture(content, node, image));\n\t\t\t\t} else {\n\t\t\t\t\t// e.g. <img src=\"./foo.svg\" /> => <img src={___ASSET___0} />\n\t\t\t\t\tconst name = ASSET_PREFIX + imports.size;\n\t\t\t\t\tconst { start, end } = src_attribute;\n\t\t\t\t\t// update src with reference to imported asset\n\t\t\t\t\ts.update(\n\t\t\t\t\t\tis_quote(content, start - 1) ? start - 1 : start,\n\t\t\t\t\t\tis_quote(content, end) ? end + 1 : end,\n\t\t\t\t\t\t`{${name}}`\n\t\t\t\t\t);\n\t\t\t\t\t// update `enhanced:img` to `img`\n\t\t\t\t\ts.update(node.start + 1, node.start + 1 + 'enhanced:img'.length, 'img');\n\t\t\t\t\timports.set(original_url, name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: switch to zimmerframe with Svelte 5\n\t\t\t// @ts-ignore\n\t\t\tawait asyncWalk(ast.html, {\n\t\t\t\t/**\n\t\t\t\t * @param {import('svelte/types/compiler/interfaces').TemplateNode} node\n\t\t\t\t */\n\t\t\t\tasync enter(node) {\n\t\t\t\t\tif (node.type === 'Element') {\n\t\t\t\t\t\t// Compare node tag match\n\t\t\t\t\t\tif (node.name === 'enhanced:img') {\n\t\t\t\t\t\t\tconst src = get_attr_value(node, 'src');\n\t\t\t\t\t\t\tif (!src) return;\n\t\t\t\t\t\t\tawait update_element(node, src);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// add imports\n\t\t\tif (imports.size) {\n\t\t\t\tlet import_text = '';\n\t\t\t\tfor (const [path, import_name] of imports.entries()) {\n\t\t\t\t\timport_text += `import ${import_name} from \"${path}\";`;\n\t\t\t\t}\n\t\t\t\tif (ast.instance) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\ts.appendLeft(ast.instance.content.start, import_text);\n\t\t\t\t} else {\n\t\t\t\t\ts.append(`<script>${import_text}</script>`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcode: s.toString(),\n\t\t\t\tmap: s.generateMap()\n\t\t\t};\n\t\t}"}]}